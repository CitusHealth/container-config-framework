# This is considered a "typical" container Makefile and is designed to be 
# symlink'd from a container directory as "Makefile"

SHELL := /bin/bash
MAKEFLAGS := silent

CURRENT_DIR_PATH := $(shell echo `pwd`)
CURRENT_DIR_NAME := $(shell basename `pwd`)

CONTAINER_NAME := $(CURRENT_DIR_NAME)
CONTAINER_DEFN_HOME := $(CURRENT_DIR_PATH)
CONTAINER_DOCKERFILE := Dockerfile

CONTAINER_IS_RUNNING := $(shell docker ps --filter "name=$(CONTAINER_NAME)" --filter "status=running" --quiet)
OSQUERY_INSTALLED := $(shell command -v osqueryi 2> /dev/null)

CCF_HOME ?= /opt/container-config-framework
CCF_FACTS_FILES ?= $(CCF_HOME)/etc/facts-generator.ccf-conf.jsonnet:$(HOME)/.ccf/etc/facts-generator.ccf-conf.jsonnet
JSONNET_PATH ?= $(HOME)/.ccf/secrets:$(HOME)/.ccf/etc:$(CCF_HOME)/lib:$(CCF_HOME)/etc

# This is the primary JSonnet configuration file, it creates all the container's
# definition and configuration files using Jsonnet -m (multi-file) strategy.
CONTAINER_DEFN_JSONNET ?= container.ccf-defn.jsonnet

# This file holds the list of files generated by the jsonnet --multi command
CONTAINER_DEFN_JSONNET_GENERATED_FILES_LIST := .ccf_container.ccf-defn.jsonnet_generated
DELETE_GENERATED_FILES_SCRIPT := .ccf_delete_generated_files.sh

CUSTOM_POST_CONFIGURE_SCRIPT_NAME := ./after_configure.make-plugin.sh
CUSTOM_POST_START_SCRIPT_NAME := ./after_start.make-plugin.sh
CUSTOM_INCLUDE_FILE := ./container.make.inc

# This is the "environment facts bootstrap" scripts which figures out what's in the
# runtime environment and stores that data in the destination path. That destination
# path is then available in JSONNET_PATH for use in container.ccf-defn.jsonnet.
ENVFACTS_GENERATOR_SCRIPT ?= $(CCF_HOME)/bin/generate-facts.sh
ENVFACTS_GENERATOR_DEST_PATH_RELATIVE ?= .ccf_facts
ENVFACTS_GENERATOR_DEST_PATH_ABSOLUTE ?= $(CONTAINER_DEFN_HOME)/.ccf_facts

default: inspect

generate-container-conf:
	mkdir -p $(ENVFACTS_GENERATOR_DEST_PATH_RELATIVE)
	echo "Running $(ENVFACTS_GENERATOR_SCRIPT), dest $(ENVFACTS_GENERATOR_DEST_PATH_RELATIVE)"
	CCF_HOME=$(CCF_HOME) CCF_FACTS_FILES=$(CCF_FACTS_FILES) CONTAINER_DEFN_HOME=$(CONTAINER_DEFN_HOME) CONTAINER_NAME=$(CONTAINER_NAME) \
	    JSONNET_PATH="$(JSONNET_PATH)" DEST_PATH=$(ENVFACTS_GENERATOR_DEST_PATH_ABSOLUTE) \
		bash $(ENVFACTS_GENERATOR_SCRIPT)

	JSONNET_PATH="$(JSONNET_PATH)" \
			jsonnet --jpath $(ENVFACTS_GENERATOR_DEST_PATH_ABSOLUTE) \
					-S --multi . $(CONTAINER_DEFN_JSONNET) > $(CONTAINER_DEFN_JSONNET_GENERATED_FILES_LIST)
	
	echo "Generated container definitions from $(CONTAINER_DEFN_JSONNET) (stored in $(CONTAINER_DEFN_JSONNET_GENERATED_FILES_LIST)):"
	cat $(CONTAINER_DEFN_JSONNET_GENERATED_FILES_LIST)  | sed 's/^\.\//  > /'
	echo "Created .gitignore to prevent tracking of generated files"
	echo "# Generated by Makefile. DO NOT EDIT" > .gitignore
	echo $(CONTAINER_DEFN_JSONNET_GENERATED_FILES_LIST) >> .gitignore
	echo $(DELETE_GENERATED_FILES_SCRIPT) >> .gitignore
	echo $(ENVFACTS_GENERATOR_DEST_PATH_RELATIVE) >> .gitignore
	cat $(CONTAINER_DEFN_JSONNET_GENERATED_FILES_LIST) | sed 's/^\.\///' >> .gitignore
	cat $(CONTAINER_DEFN_JSONNET_GENERATED_FILES_LIST) | sed 's/^/rm -f /' > $(DELETE_GENERATED_FILES_SCRIPT)

clean-generated-container-conf:
	bash $(DELETE_GENERATED_FILES_SCRIPT)
	echo "Ran $(DELETE_GENERATED_FILES_SCRIPT)"
	rm -f $(CONTAINER_DEFN_JSONNET_GENERATED_FILES_LIST)
	rm -f $(DELETE_GENERATED_FILES_SCRIPT)
	rm -rf $(ENVFACTS_GENERATOR_DEST_PATH_ABSOLUTE)
	echo "Deleted $(CONTAINER_DEFN_JSONNET_GENERATED_FILES_LIST) and $(DELETE_GENERATED_FILES_SCRIPT)"

.ONESHELL:
## Generate all container artifacts from Jsonnet config
configure: generate-container-conf
	if [ -f $(CUSTOM_POST_CONFIGURE_SCRIPT_NAME) ]; then
		echo "Found custom configuration script $(CUSTOM_POST_CONFIGURE_SCRIPT_NAME) for $(CONTAINER_NAME)"
		sudo chmod +x $(CUSTOM_POST_CONFIGURE_SCRIPT_NAME)
		$(CUSTOM_POST_CONFIGURE_SCRIPT_NAME) $(CONTAINER_NAME)
	fi

## Opposite of configure, remove all generated artifacts and "reset" directory
unconfigure: clean-generated-container-conf

## Run unconfigure and then configure (clean and re-create)
reconfigure: clean-generated-container-conf configure

.ONESHELL:
## Start the container and all dependencies
start: configure
	docker-compose up -d --force-recreate
	if [ -f $(CUSTOM_POST_START_SCRIPT_NAME) ]; then
		echo "Found custom start script $(CUSTOM_POST_START_SCRIPT_NAME) for $(CONTAINER_NAME)"
		sudo chmod +x $(CUSTOM_POST_START_SCRIPT_NAME)
		$(CUSTOM_POST_START_SCRIPT_NAME) $(CONTAINER_NAME)
	fi

shell:
	docker run -it --entrypoint="/bin/sh" $(CONTAINER_NAME) 

bash:
	docker run -it --entrypoint="/bin/bash" $(CONTAINER_NAME)

## If the container is running, inspect its settings
inspect:
ifdef CONTAINER_IS_RUNNING
	docker ps -a --filter "name=$(CONTAINER_NAME)" --format "table {{.ID}} {{.Names}}\t{{.Status}}\t{{.Ports}}\\t{{.Networks}}"
	docker images $(CONTAINER_NAME)
	printf "Volumes: "
	docker inspect -f '{{ json .Mounts }}' $(CONTAINER_NAME) | jq 
else
	echo "Container $(CONTAINER_NAME) is not running, here's docker ps -a:"
	echo ''
	docker ps -a --format "table {{.ID}} {{.Names}}\t{{.Status}}"
endif

## If the container is running, show its logs
logs:
ifdef CONTAINER_IS_RUNNING
	docker logs $(CONTAINER_NAME)
else
	echo "Container $(CONTAINER_NAME) is not running, here's docker ps -a:"
	echo ''
	docker ps -a --format "table {{.ID}} {{.Names}}\t{{.Status}}"
endif

## If the container is running, show its ports
ports:
ifdef CONTAINER_IS_RUNNING
	docker port $(CONTAINER_NAME)
else
	echo "Container $(CONTAINER_NAME) is not running, here's docker ps -a:"
	echo ''
	docker ps -a --format "table {{.ID}} {{.Names}}\t{{.Status}}"
endif

## Stop the container but retain volumes and generated files
stop: 
	docker-compose down

## Stop the container and delete associated volumes
kill: 
	docker-compose down --volumes

## Stop the container and clean up generated files
clean: kill clean-generated-container-conf

.ONESHELL:
## Build the container using Dockerfile in this directory
build: configure
	if [ -f $(CONTAINER_DOCKERFILE) ]; then
		docker images $(CONTAINER_NAME)
		echo "Removing image $(CONTAINER_NAME)"
		docker rmi --force $(CONTAINER_NAME)
		docker build --force-rm --no-cache --tag $(CONTAINER_NAME) .
	else
		echo "No $(CONTAINER_DOCKERFILE) found for $(CONTAINER_NAME)."
	fi

## Show images associated with this container
show-images:
	docker images $(CONTAINER_NAME)

## Remove any images associated with this container
clean-images:
	docker images $(CONTAINER_NAME)
	echo "Removing image $(CONTAINER_NAME)"
	docker rmi --force $(CONTAINER_NAME)

## Remove all containers that have exited (not specific to this container)
clean-exited-containers:
	docker ps -aq --no-trunc -f status=exited | xargs docker rm

## Remove all dangling or untagged container images (not specific to this container)
clean-dangling-untagged-container-images:
	docker images -q --filter dangling=true | xargs docker rmi

## See if all developer dependencies are installed
check-dependencies: check-jsonnet check-jq check-docker check-docker-compose check-user-in-docker-group check-osquery
	printf "[*] "
	make -v | head -1
	echo "[*] Shell: $$SHELL"

JSONNET_INSTALLED := $(shell command -v jsonnet 2> /dev/null)
check-jsonnet:
ifndef JSONNET_INSTALLED
	echo "[ ] Did not find jsonnet, run this to set it up:"
	echo "    sudo ln -s /opt/container-config-framework/bin/jsonnet-v0.11.2 /usr/bin/jsonnet"
else
	printf "[*] "
	jsonnet --version
endif

JQ_INSTALLED := $(shell command -v jq 2> /dev/null)
check-jq:
ifndef JQ_INSTALLED
	echo "[ ] Did not find jq, install using:"
	echo "    sudo apt-get install jq"
else
	printf "[*] "
	jq --version
endif

USER_IN_DOCKER_GROUP := $(shell groups $$USER | grep '\bdocker\b')
check-user-in-docker-group:
ifndef USER_IN_DOCKER_GROUP
	echo "[ ] User $$USER is not in docker group, sudo will be required and scripts won't work."
else
	echo "[*] User $$USER is in docker group"
endif

DOCKER_INSTALLED := $(shell command -v docker 2> /dev/null)
check-docker:
ifndef DOCKER_INSTALLED
	echo "[ ] Unable to find docker, install it using 'make setup-docker'."
else
	printf "[*] "
	docker --version
endif

DOCKER_COMPOSE_INSTALLED := $(shell command -v docker-compose 2> /dev/null)
check-docker-compose: check-docker
ifndef DOCKER_COMPOSE_INSTALLED
	echo "[ ] Unable to find docker-compose, install it using 'make setup-docker'."
else
	printf "[*] "
	docker-compose --version
endif

check-osquery: 
ifndef OSQUERY_INSTALLED
	echo "[ ] Unable to find osquery, install it from https://osquery.io/downloads/official."
else
	printf "[*] "
	osqueryi --version
endif

TARGET_MAX_CHAR_NUM=10
# All targets should have a ## Help text above the target and they'll be automatically collected
# Show help, using auto generator from https://gist.github.com/prwhite/8168133
help: generate-container-conf
	@echo ''
	@echo 'Usage:'
	@echo '  ${YELLOW}make${RESET} ${GREEN}<target>${RESET}'
	@echo ''
	@echo 'Targets:'
	@awk '/^[a-zA-Z\-\_0-9]+:/ { \
		helpMessage = match(lastLine, /^## (.*)/); \
		if (helpMessage) { \
			helpCommand = substr($$1, 0, index($$1, ":")); \
			helpMessage = substr(lastLine, RSTART + 3, RLENGTH); \
			printf "  ${YELLOW}%-$(TARGET_MAX_CHAR_NUM)s${RESET} ${GREEN}%s${RESET}\n", helpCommand, helpMessage; \
		} \
	} \
	{ lastLine = $$0 }' $(MAKEFILE_LIST)
	@echo ''	
	@echo 'JSONNET_PATH=$(JSONNET_PATH)'
	@echo '$(ENVFACTS_GENERATOR_DEST_PATH_RELATIVE):'
	ls -al $(ENVFACTS_GENERATOR_DEST_PATH_ABSOLUTE)

ifneq ("$(wildcard $(CUSTOM_INCLUDE_FILE))","")
include $(CUSTOM_INCLUDE_FILE)
endif

